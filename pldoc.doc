\documentclass[11pt]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{html}
\sloppy
\makeindex

\onefile
\htmloutput{html}				% Output directory
\htmlmainfile{index}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{SWI-Prolog documentation package}

\begin{document}

\title{SWI-Prolog Source Documention}
\author{Jan Wielemaker \\
	HCS, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{wielemak@science.uva.nl}}

\maketitle

\begin{abstract}
This article presents PlDoc, the SWI-Prolog source-code documentation
infrastructure which is loosely based on JavaDoc.
\end{abstract}

\pagebreak
\tableofcontents

\vfill
\vfill

\newpage

\section{Introduction}

When developing Prolog source that has to be maintained for a longer
period or is developed by a ---possibly distributed--- team some basic
quality measurements need to be adopted. A shared and well designed
codingstyle is one of them. In addition, documentation of source-files
and their primary interfaces as well as a testing framework must be
established.

Only a few documentation and testing frameworks exist in the Prolog
world. In my view they all fall short realising the basic needs in a
lightweight and easy to addopt system. We have noticed in various
projects as well as through the codee we receive in the cause of testing
and debugging SWI-Prolog that the discipline to come with consistent
style, well commented code and a test-suite is not very well established
in the Prolog community.  If we want to improve this practice, we should
make sure that

\begin{shortlist}
    \item The documentation and testing framework requires the
	  minimum of work and learning.
    \item The framework is immediately rewarding to the individual
          programmer as well as the team,
\end{shortlist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview}

The PlDoc infrastructure is based on \emph{structured comments}, just
like JavaDoc.  Using comments, no changes have to be made to Prolog to
load the documented source.  If the \pllib{pldoc} library is loaded, 
Prolog will not only load the source, but also parse all structured
comments.  It processes the mode-declarations inside the comments and
stores these as annotations in the Prolog database to support the test
framework and other runtime and compiletime analysis tools that may be
developed in the future.

Documentation for all or some of the loaded files can be written to file
in either HTML+CSS or \LaTeX{} format. Each source file is documented in
a single file. In addition, the documentation generator will generate an
index file that can be used a index for a browser or input file for
\LaTeX{} for producing nicely typeset document.

To support the developer, the documentation system can be asked to start
a web-server that can be used to browse the documentation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Wiki notation}

Structured comments that provide part of the documentation are written
in Wiki notation, using a subset from the conventions of
\url[TWiki]{http://www.twiki.org}, with some Prolog specific additions.

\subsection{Structuring conventions}

\begin{description}
    \item [Paragraphs]
Paragraphs are seperated by a blank line.

    \item [Lists]
The wiki knows three types of lists: \emph{bullet lists} (HTML
\const{ul}), \emph{numbered lists} (HTML \const{ol}) and
\emph{description lists} (HTML \const{dl}). Each list environment is
headed by an empty line and each list-item has a special symbol at the
start, followed by a space.  Each subsequent item must be indented at
exactly the same column.  Lists may be nested by starting a new list at
a higher level of indentation.  The list prefixes are:

\begin{center}
\begin{tabular}{lp{0.7\linewidth}}
 \tt *	& Bulleted list item \\
 \tt 1.	& Numbered list item.  Any number from 1..9 is allowed, which
	  allows for proper numbering in the source.  Actual numbers
	  in the HTML or \LaTeX{} however are re-generated, starting
	  at 1. \\
 \tt \$ Title : Item & Description list item.
\end{tabular}
\end{center}

    \item [Tables]
The Wiki provides only for limited support for tables.   A table-row
is started by a \chr{|} sign and the cells are separated by the same
character.  The last cell must be ended with \chr{|}.  Multiple lines
that parse into a table-row together for a table.  Example:

\begin{verbatim}
	| Author    | Jan Wielemaker |
	| Copyright | GPL            |
\end{verbatim}
\end{description}

\subsection{Text markup: fonts and links}

Wiki text markup to realise fonts is mostly based on old plaintext
conventions in newsnet and E-mail.  We added some Prolog specific
conventions to this.  For font changing code, The opening symbol must
be followed immediately by a word and the closing one must immediately
follow a word.

\begin{center}
\begin{tabular}{lp{0.7\linewidth}}
\tt *bold text*	& Typset text between `*' in bold \\
\tt _emphasize_ & Typset text between `_' as _emphasized  \\
\tt =code=      & Typset text between `=' in fixed font \\
\tt name/arity  & Create a link to a predicate \\
\tt name//arity & Create a link to a DCG rule \\
\tt Word	& Capitalised words that appear as argument-name
		  are written using \verb$<var>Word</var>$ \\
\end{tabular}
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Motivation of choices}

Literal programming is an old field.  The \TeX{} source is one of the
oldest and welknown examples of this approach were input files are a 
mixture of \TeX{} and PASCAL source. External tools are used to untangle
the common source, process one branche to produce the documentation
while the other is compiled to produce the program.

A program and its documentation consists of various different parts:

\begin{shortlist}
    \item The program text itself.  This is the minimum that must be
          handed to the compiler to create an executable (module).
    \item Meta information about the program: author, modifications,
          license, etc.
    \item Documentation about the overall structure and purpose of
	  the source.
    \item Description of the interface: public predicates, their
	  types, modes and whether or not they are deterministic as
	  wel as an informative text on each public predicate.
    \item Description of key private predicates necessary to understand
	  how the public interface is realised.
\end{shortlist}

\subsection*{Structured comments or directives}

Comments can be added through Prolog directives, a route taken by Ciao
Prolog and Logtalk. We feel structured comments are a better alternative
for the following reasons:

\begin{itemize}
    \item Prolog programmers are used to writing comments as Prolog
          comments.
    \item Using Prolog strings requires unnatural escape sequences for
	  string quotes and long literal values tend to result in hard
	  to find quote-mismatches.
    \item Comments should not look like code, as that makes it more
	  difficult to find the actual code.
\end{itemize}

We are aware that the above problems can be dealt with using
syntax-aware editors. Only a few editors are sufficiently powerful to
support this correctly though and we do not expect the required advanced
modes to be widely available.  Using comments we do not need to force
users into using a particular editor.

\subsection{Wiki or HTML}

JavaDoc uses HTML as markup inside the structured comments. Although
HTML is more widely known than ---for example--- \LaTeX{} or TeXinfo,
we think the Wiki approach using text with minimal layout conventions
taken largely from plaintext newsnet and E-mail is more attractive.
Wiki input is notably much easier to read in the source-file than
HTML without syntax support from an editor.


\subsection*{Types and modes}

Types and modes are not a formal part of the Prolog language.
Nevertheless, their role goes beyond purely documentation. The test
system can use information about non-determinism to validate that
deterministic calls are indeed deterministic.  Type information can
be used to analyse coverage from the test-suite, to generate runtime
type verification or to perform static type-analysis.  We have choosen
to use a structured comment with formal syntax for the following
reasons:

\begin{itemize}
    \item As a comment, they stay together with the comment block
          of a predicate. we feel it is best to keep documentation
	  as close as possible to the source.
    \item As we parse them seperately, we can pick up predicate names
	  and create a readable syntax without introducing possibly
	  conflicting operators.
    \item As a comment they do not introduce incompatibilities with
          other Prolog systems.
\end{itemize}


\subsection*{Few requirements}

SWI-Prolog aims at platform independency. We want to tools to rely as
much as possible on Prolog itself. Therefore the entire infrastructure
is written in Prolog. Output as HTML is suitable for browsing and not
very high quality printing on virtuall every platform. Output to
\LaTeX{} requires more infrastructure for processing, but allows for
producing high-quality PDF documents.

\printindex

\end{document}

